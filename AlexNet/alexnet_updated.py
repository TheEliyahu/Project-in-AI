# -*- coding: utf-8 -*-
"""AlexNet - Updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d5Gl79y6tsEiiyIAqw1ymJbBKo9eGCMW
"""

import os
import zipfile
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
from google.colab import files

# Paths for zip file and extraction
zip_file_path = '/content/Brain MRI.zip'  # Path to uploaded zip file
extracted_folder = '/content/brain_tumor_dataset'

# Ensure the extraction directory exists
os.makedirs(extracted_folder, exist_ok=True)

# Extract the zip file
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extracted_folder)
print("Extraction completed successfully.")

#Define parameters
data_dir = os.path.join(extracted_folder, 'Training')  # Adjust path if needed
img_height = 224
img_width = 224
batch_size = 32

# Create ImageDataGenerators
train_datagen = ImageDataGenerator(
    rescale=1.0 / 255,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    rotation_range=20,
    validation_split=0.2,
    fill_mode='nearest'
)

# Training data generator
train_data = train_datagen.flow_from_directory(
    data_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical',
    subset='training'  # Training subset
)
# Validation data generator
val_data = train_datagen.flow_from_directory(
    data_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical',
    subset='validation'  # Validation subset
)



#Define AlexNet architecture
input_layer = Input(shape=(img_height, img_width, 3))

# First Convolutional Layer
x = Conv2D(96, (11, 11), strides=(4, 4), activation='relu')(input_layer)
x = MaxPooling2D((3, 3), strides=(2, 2))(x)

# Second Convolutional Layer
x = Conv2D(256, (5, 5), padding='same', activation='relu')(x)
x = MaxPooling2D((3, 3), strides=(2, 2))(x)

# Third Convolutional Layer
x = Conv2D(384, (3, 3), padding='same', activation='relu')(x)

# Fourth Convolutional Layer
x = Conv2D(384, (3, 3), padding='same', activation='relu')(x)

# Fifth Convolutional Layer
x = Conv2D(256, (3, 3), padding='same', activation='relu')(x)
x = MaxPooling2D((3, 3), strides=(2, 2))(x)

# Flatten and fully connected layers
x = Flatten()(x)
x = Dense(4096, activation='relu')(x)
x = Dropout(0.5)(x)
x = Dense(4096, activation='relu')(x)
x = Dropout(0.5)(x)

# Output layer with 4 classes (adjust if needed)
predictions = Dense(4, activation='softmax')(x)

# Define the model
model = Model(inputs=input_layer, outputs=predictions)

# Compile the model
model.compile(optimizer=Adam(), loss='categorical_crossentropy', metrics=['accuracy'])

# Print model summary
model.summary()

# Define callbacks
early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2, patience=3, min_lr=1e-6)

# Train the model
history = model.fit(
    train_data,
    validation_data=val_data,
    epochs=25,  # Adjust epochs as needed
    callbacks=[early_stopping, reduce_lr]
)
model.save('/content/data/Brain_Tumor_AlexNet.keras')

os.makedirs('/content/data/', exist_ok=True)
model.save('/content/data/Brain_Tumor_AlexNet.keras')

from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import f1_score, classification_report
import numpy as np
import os

# Paths
tf_model_path = '/content/data/Brain_Tumor_AlexNet.keras'  # Path to AlexNet model
test_dir = '/content/brain_tumor_dataset/Testing'

# Load the AlexNet model
model = load_model(tf_model_path)
print("Model loaded successfully!")

# Parameters
img_height = 224
img_width = 224
batch_size = 32

# Prepare the test data generator
test_datagen = ImageDataGenerator(rescale=1./255)

test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical',
    shuffle=False
)

# Get true labels and predictions
true_labels = test_generator.classes
predictions = model.predict(test_generator)
predicted_classes = np.argmax(predictions, axis=1)

# Calculate F1-Score
f1 = f1_score(true_labels, predicted_classes, average='weighted')  # Use 'weighted' for imbalanced datasets
print(f"Weighted F1-Score: {f1:.4f}")

# Detailed Classification Report
class_indices = test_generator.class_indices
class_labels = {v: k for k, v in class_indices.items()}  # Reverse the class_indices
report = classification_report(true_labels, predicted_classes, target_names=class_labels.values())
print("\nClassification Report:\n")
print(report)

# Save Classification Report to File
with open('classification_report.txt', 'w') as f:
    f.write(report)
print("Classification report saved to 'classification_report.txt'")



import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from tensorflow.keras.models import load_model  # Import load_model
from tensorflow.keras.preprocessing.image import ImageDataGenerator # Import ImageDataGenerator


try:
    model
except NameError:
    model = load_model('/content/Brain_Tumor_AlexNet.keras')
    print("Model loaded for confusion matrix.")

# --- Define test_generator here ---
# Parameters
img_height = 224
img_width = 224
batch_size = 32
test_dir = '/content/brain_tumor_dataset/Testing'

# Prepare the test data generator
test_datagen = ImageDataGenerator(rescale=1./255)

test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical',
    shuffle=False
)
# --- End of test_generator definition ---


# Use test_generator instead of test_data for predictions
predictions = model.predict(test_generator)

# Convert predictions to class labels if necessary
predicted_classes = predictions.argmax(axis=1)  # For multi-class classification

# true_labels should be assigned to test_generator.classes
true_labels = test_generator.classes

# Compute the confusion matrix
cm = confusion_matrix(true_labels, predicted_classes)

# Get the class labels from the test data generator
class_labels = list(test_generator.class_indices.keys())

# Display confusion matrix
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=class_labels) # Use class_labels instead of your_class_labels
disp.plot(cmap=plt.cm.Blues)
plt.title("Confusion Matrix")
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Get true labels and predictions
true_labels = test_generator.classes
predictions = model.predict(test_generator)
predicted_classes = np.argmax(predictions, axis=1)

# Assuming 'test_generator' has access to the original images:
X_test = test_generator.filepaths  # Get the file paths of the test images
Y_test = true_labels  # Assuming 'true_labels' are the ground truth labels
y_pred = predicted_classes  # Assuming 'predicted_classes' are the model's predictions

# Assuming 'class_labels' from the confusion matrix code contains the label names:
labels = class_labels

# Create a mapping from class index to label name
labels_dict = {i: label for i, label in enumerate(labels)}

# Plot a subset of the test images with predictions
plt.figure(figsize=(20, 20))
num_images_to_plot = min(20, len(X_test))  # Limit to 20 images or the number of test images
for i in range(num_images_to_plot):
    plt.subplot(5, 4, i + 1)
    # Load and display image
    img = plt.imread(X_test[i])  # Load image using file path
    plt.imshow(img)

    # Display true and predicted labels
    true_label = labels_dict.get(Y_test[i], "Unknown")  # Get label name from index
    predicted_label = labels_dict.get(y_pred[i], "Unknown")  # Get label name from index
    plt.title(f"Truth: {true_label}\nPredicted: {predicted_label}")
    plt.axis('off')
plt.show()